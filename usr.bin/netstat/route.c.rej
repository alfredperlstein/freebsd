@@ -78,32 +79,33 @@
 struct bits {
 	u_long	b_mask;
 	char	b_val;
+	const char *b_name;
 } bits[] = {
-	{ RTF_UP,	'U' },
-	{ RTF_GATEWAY,	'G' },
-	{ RTF_HOST,	'H' },
-	{ RTF_REJECT,	'R' },
-	{ RTF_DYNAMIC,	'D' },
-	{ RTF_MODIFIED,	'M' },
-	{ RTF_DONE,	'd' }, /* Completed -- for routing messages only */
-	{ RTF_XRESOLVE,	'X' },
-	{ RTF_STATIC,	'S' },
-	{ RTF_PROTO1,	'1' },
-	{ RTF_PROTO2,	'2' },
-	{ RTF_PRCLONING,'c' },
-	{ RTF_PROTO3,	'3' },
-	{ RTF_BLACKHOLE,'B' },
-	{ RTF_BROADCAST,'b' },
+	{ RTF_UP,	'U', "up" },
+	{ RTF_GATEWAY,	'G', "gateway" },
+	{ RTF_HOST,	'H', "host" },
+	{ RTF_REJECT,	'R', "reject" },
+	{ RTF_DYNAMIC,	'D', "dynamic" },
+	{ RTF_MODIFIED,	'M', "modified" },
+	{ RTF_DONE,	'd', "done" }, /* Completed -- for routing messages only */
+	{ RTF_XRESOLVE,	'X', "xresolve" },
+	{ RTF_STATIC,	'S', "static" },
+	{ RTF_PROTO1,	'1', "proto1" },
+	{ RTF_PROTO2,	'2', "proto2" },
+	{ RTF_PRCLONING,'c', "prcloning" },
+	{ RTF_PROTO3,	'3', "proto3" },
+	{ RTF_BLACKHOLE,'B', "blackhole" },
+	{ RTF_BROADCAST,'b', "broadcast" },
 #ifdef RTF_LLINFO
-	{ RTF_LLINFO,	'L' },
+	{ RTF_LLINFO,	'L', "llinfo" },
 #endif
 #ifdef RTF_WASCLONED
-	{ RTF_WASCLONED,'W' },
+	{ RTF_WASCLONED,'W', "wascloned" },
 #endif
 #ifdef RTF_CLONING
-	{ RTF_CLONING,	'C' },
+	{ RTF_CLONING,	'C', "cloning" },
 #endif
-	{ 0 , 0 }
+	{ 0 , 0, NULL }
 };
 
 typedef union {
@@ -128,16 +130,17 @@
 static void size_cols(int ef, struct radix_node *rn);
 static void size_cols_tree(struct radix_node *rn);
 static void size_cols_rtentry(struct rtentry *rt);
-static void p_tree(struct radix_node *);
+static void p_tree(const char *, struct radix_node *);
 static void p_rtnode(void);
 static void ntreestuff(void);
-static void np_rtentry(struct rt_msghdr *);
-static void p_sockaddr(struct sockaddr *, struct sockaddr *, int, int);
+static void np_rtentry(const char *, struct rt_msghdr *);
+static void p_sockaddr(const char *, struct sockaddr *, struct sockaddr *,
+		       int, int);
 static const char *fmt_sockaddr(struct sockaddr *sa, struct sockaddr *mask,
     int flags);
 static void p_flags(int, const char *);
 static const char *fmt_flags(int f);
-static void p_rtentry(struct rtentry *);
+static void p_rtentry(const char *name, struct rtentry *);
 static void domask(char *, in_addr_t, u_long);
 
 /*
@@ -170,16 +173,17 @@
 	if (clock_gettime(CLOCK_UPTIME, &uptime) < 0)
 		err(EX_OSERR, "clock_gettime() failed");
 
-	printf("Routing tables");
+	xo_open_container("route-information");
+	xo_emit("{T:Routing tables}");
 	if (fibnum)
-		printf(" (fib: %d)", fibnum);
-	printf("\n");
+		xo_emit(" ({L:fib}: {:fib/%d})", fibnum);
+	xo_emit("\n");
 
 	if (Aflag == 0 && NewTree)
 		ntreestuff();
 	else {
 		if (rtree == 0) {
-			printf("rt_tables: symbol not in namelist\n");
+			xo_emit("rt_tables: symbol not in namelist\n");
 			return;
 		}
 
@@ -210,18 +214,25 @@
 				continue;
 			if (fam == AF_UNSPEC) {
 				if (Aflag && af == 0) {
-					printf("Netmasks:\n");
-					p_tree(head.rnh_treetop);
+					xo_emit("{T:Netmasks}:\n");
+					xo_open_list("netmasks");
+					p_tree("netmasks", head.rnh_treetop);
+					xo_close_list("netmasks");
 				}
 			} else if (af == AF_UNSPEC || af == fam) {
 				size_cols(fam, head.rnh_treetop);
+				xo_open_container("route-table");
 				pr_family(fam);
 				do_rtent = 1;
 				pr_rthdr(fam);
-				p_tree(head.rnh_treetop);
+				xo_open_list("rt-entry");
+				p_tree("rt-entry", head.rnh_treetop);
+				xo_close_list("rt-entry");
+				xo_close_container("route-table");
 			}
 		}
 	}
+	xo_close_container("route-information");
 }
 
 /*
@@ -356,10 +367,12 @@
 {
 
 	if (Aflag)
-		printf("%-8.8s ","Address");
+		xo_emit("{T:/%-8.8s} ","Address");
 	if (af1 == AF_INET || Wflag) {
 		if (Wflag) {
-			printf("%-*.*s %-*.*s %-*.*s %*.*s %*.*s %*.*s %*.*s %*s\n",
+			xo_emit(
+		"{T:/%-*.*s} {T:/%-*.*s} {T:/%-*.*s} {T:/%*.*s} "
+		"{T:/%*.*s} {T:/%*.*s} {T:/%*.*s} {T:/%*s}\n",
 				wid_dst,	wid_dst,	"Destination",
 				wid_gw,		wid_gw,		"Gateway",
 				wid_flags,	wid_flags,	"Flags",
@@ -369,7 +382,9 @@
 				wid_if,		wid_if,		"Netif",
 				wid_expire,			"Expire");
 		} else {
-			printf("%-*.*s %-*.*s %-*.*s %*.*s %*.*s %*.*s %*s\n",
+			xo_emit(
+		"{T:/%-*.*s} {T:/%-*.*s} {T:/%-*.*s} {T:/%*.*s} "
+		"{T:/%*.*s} {T:/%*.*s} {T:/%*s}\n",
 				wid_dst,	wid_dst,	"Destination",
 				wid_gw,		wid_gw,		"Gateway",
 				wid_flags,	wid_flags,	"Flags",
@@ -421,7 +437,7 @@
 }
 
 static void
-p_tree(struct radix_node *rn)
+p_tree(const char *name, struct radix_node *rn)
 {
 
 again:
@@ -431,32 +447,33 @@
 		return;
 	if (rnode.rn_bit < 0) {
 		if (Aflag)
-			printf("%-8.8lx ", (u_long)rn);
+			xo_emit("{:radix-node/%-8.8lx} ", (u_long)rn);
 		if (rnode.rn_flags & RNF_ROOT) {
 			if (Aflag)
-				printf("(root node)%s",
+				xo_emit("({:root/root} node){L:/%s}",
 				    rnode.rn_dupedkey ? " =>\n" : "\n");
 		} else if (do_rtent) {
 			if (kget(rn, rtentry) == 0) {
-				p_rtentry(&rtentry);
+				p_rtentry(name, &rtentry);
 				if (Aflag)
 					p_rtnode();
 			}
 		} else {
-			p_sockaddr(kgetsa((struct sockaddr *)rnode.rn_key),
+			p_sockaddr("address",
+				   kgetsa((struct sockaddr *)rnode.rn_key),
 				   NULL, 0, 44);
-			putchar('\n');
+			xo_emit("\n");
 		}
 		if ((rn = rnode.rn_dupedkey))
 			goto again;
 	} else {
 		if (Aflag && do_rtent) {
-			printf("%-8.8lx ", (u_long)rn);
+			xo_emit("{:radix-node/%-8.8lx} ", (u_long)rn);
 			p_rtnode();
 		}
 		rn = rnode.rn_right;
-		p_tree(rnode.rn_left);
-		p_tree(rn);
+		p_tree(name, rnode.rn_left);
+		p_tree(name, rn);
 	}
 }
 
@@ -565,24 +586,26 @@
 	mib[4] = NET_RT_DUMP;
 	mib[5] = 0;
 	if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0) {
-		err(1, "sysctl: net.route.0.0.dump estimate");
+		xo_err(1, "sysctl: net.route.0.0.dump estimate");
 	}
 
 	if ((buf = malloc(needed)) == 0) {
-		errx(2, "malloc(%lu)", (unsigned long)needed);
+		xo_errx(2, "malloc(%lu)", (unsigned long)needed);
 	}
 	if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0) {
-		err(1, "sysctl: net.route.0.0.dump");
+		xo_err(1, "sysctl: net.route.0.0.dump");
 	}
 	lim  = buf + needed;
+	xo_open_list("rt-entry");
 	for (next = buf; next < lim; next += rtm->rtm_msglen) {
 		rtm = (struct rt_msghdr *)next;
-		np_rtentry(rtm);
+		np_rtentry("rt-entry", rtm);
 	}
+	xo_close_list("rt-entry");
 }
 
 static void
-np_rtentry(struct rt_msghdr *rtm)
+np_rtentry(const char *name, struct rt_msghdr *rtm)
 {
 	struct sockaddr *sa = (struct sockaddr *)(rtm + 1);
 #ifdef notdef
@@ -594,7 +617,7 @@
 #ifdef notdef
 	/* for the moment, netmasks are skipped over */
 	if (!banner_printed) {
-		printf("Netmasks:\n");
+		xo_emit("{T:Netmasks}:\n");
 		banner_printed = 1;
 	}
 	if (masks_done == 0) {
@@ -609,31 +632,39 @@
 		pr_family(af1);
 		old_af = af1;
 	}
+	xo_open_instance(name);
 	if (rtm->rtm_addrs == RTA_DST)
-		p_sockaddr(sa, NULL, 0, 36);
+		p_sockaddr("destination", sa, NULL, 0, 36);
 	else {
-		p_sockaddr(sa, NULL, rtm->rtm_flags, 16);
+		p_sockaddr("XXXend-point", sa, NULL, rtm->rtm_flags, 16);
 		sa = (struct sockaddr *)(SA_SIZE(sa) + (char *)sa);
-		p_sockaddr(sa, NULL, 0, 18);
+		p_sockaddr("XXXend-point2", sa, NULL, 0, 18);
 	}
-	p_flags(rtm->rtm_flags & interesting, "%-6.6s ");
-	putchar('\n');
+	p_flags(rtm->rtm_flags & interesting, "{d:flags/%-6.6s} ");
+	xo_close_instance(name);
+	xo_emit("\n");
 }
 
 static void
-p_sockaddr(struct sockaddr *sa, struct sockaddr *mask, int flags, int width)
+p_sockaddr(const char *name, struct sockaddr *sa, struct sockaddr *mask,
+	   int flags, int width)
 {
 	const char *cp;
+	char buf[128];
 
 	cp = fmt_sockaddr(sa, mask, flags);
 
-	if (width < 0 )
-		printf("%s ", cp);
-	else {
-		if (numeric_addr)
-			printf("%-*s ", width, cp);
-		else
-			printf("%-*.*s ", width, width, cp);
+	if (width < 0) {
+		snprintf(buf, sizeof(buf), "{:%s/%%s} ", name);
+		xo_emit(buf, cp);
+	} else {
+		if (numeric_addr) {
+			snprintf(buf, sizeof(buf), "{:%s/%%-*s} ", name);
+			xo_emit(buf, width, cp);
+		} else {
+			snprintf(buf, sizeof(buf), "{:%s/%%-*..*s} ", name);
+			xo_emit(buf, width, width, cp);
+		}			
 	}
 }
 
@@ -787,7 +826,7 @@
 }
 
 static void
-p_rtentry(struct rtentry *rt)
+p_rtentry(const char *name, struct rtentry *rt)
 {
 	static struct ifnet ifnet, *lastif;
 	static char buffer[128];
@@ -795,24 +834,28 @@
 	struct sockaddr *sa;
 	sa_u addr, mask;
 
+	xo_open_instance(name);
+
 	bzero(&addr, sizeof(addr));
 	if ((sa = kgetsa(rt_key(rt))))
 		bcopy(sa, &addr, sa->sa_len);
 	bzero(&mask, sizeof(mask));
 	if (rt_mask(rt) && (sa = kgetsa(rt_mask(rt))))
 		bcopy(sa, &mask, sa->sa_len);
-	p_sockaddr(&addr.u_sa, &mask.u_sa, rt->rt_flags, wid_dst);
-	p_sockaddr(kgetsa(rt->rt_gateway), NULL, RTF_HOST, wid_gw);
-	snprintf(buffer, sizeof(buffer), "%%-%d.%ds ", wid_flags, wid_flags);
+	p_sockaddr("destination", &addr.u_sa, &mask.u_sa, rt->rt_flags, wid_dst);
+	p_sockaddr("gateway", kgetsa(rt->rt_gateway), NULL, RTF_HOST, wid_gw);
+	snprintf(buffer, sizeof(buffer),
+		 "{d:flags/%%-%d.%ds} ", wid_flags, wid_flags);
 	p_flags(rt->rt_flags, buffer);
 	if (addr.u_sa.sa_family == AF_INET || Wflag) {
-		printf("%*d %*lu ", wid_refs, rt->rt_refcnt,
-				     wid_use, rt->rt_use);
+		xo_emit("{t:reference/%*d} {t:use/%*lu} ",
+			wid_refs, rt->rt_refcnt,
+			wid_use, rt->rt_use);
 		if (Wflag) {
 			if (rt->rt_rmx.rmx_mtu != 0)
-				printf("%*lu ", wid_mtu, rt->rt_rmx.rmx_mtu);
+				xo_emit("{t:mtu/%*lu} ", wid_mtu, rt->rt_rmx.rmx_mtu);
 			else
-				printf("%*s ", wid_mtu, "");
+				xo_emit("{P:/%*s} ", wid_mtu, "");
 		}
 	}
 	if (rt->rt_ifp) {
@@ -824,18 +867,20 @@
 				strlcpy(prettyname, "---", sizeof(prettyname));
 			lastif = rt->rt_ifp;
 		}
-		printf("%*.*s", wid_if, wid_if, prettyname);
+		xo_emit("{t:interface-name/%*.*s}", wid_if, wid_if, prettyname);
 		if (rt->rt_rmx.rmx_expire) {
 			time_t expire_time;
 
 			if ((expire_time =
 			    rt->rt_rmx.rmx_expire - uptime.tv_sec) > 0)
-				printf(" %*d", wid_expire, (int)expire_time);
+				xo_emit(" {:expire-time/%*d}",
+					wid_expire, (int)expire_time);
 		}
 		if (rt->rt_nodes[0].rn_dupedkey)
-			printf(" =>");
+			xo_emit(" {:duped-key/=>}");
 	}
-	putchar('\n');
+	xo_emit("\n");
+	xo_close_instance(name);
 }
 
 char *
@@ -1044,30 +1089,36 @@
 	int rttrash;
 
 	if (rtsaddr == 0) {
-		printf("rtstat: symbol not in namelist\n");
+		xo_emit("{W:rtstat: symbol not in namelist}\n");
 		return;
 	}
 	if (rttaddr == 0) {
-		printf("rttrash: symbol not in namelist\n");
+		xo_emit("{W:rttrash: symbol not in namelist}\n");
 		return;
 	}
 	kread(rtsaddr, (char *)&rtstat, sizeof (rtstat));
 	kread(rttaddr, (char *)&rttrash, sizeof (rttrash));
-	printf("routing:\n");
+	xo_emit("{T:routing}:\n");
 
 #define	p(f, m) if (rtstat.f || sflag <= 1) \
-	printf(m, rtstat.f, plural(rtstat.f))
+	xo_emit(m, rtstat.f, plural(rtstat.f))
 
-	p(rts_badredirect, "\t%hu bad routing redirect%s\n");
-	p(rts_dynamic, "\t%hu dynamically created route%s\n");
-	p(rts_newgateway, "\t%hu new gateway%s due to redirects\n");
-	p(rts_unreach, "\t%hu destination%s found unreachable\n");
-	p(rts_wildcard, "\t%hu use%s of a wildcard route\n");
+	p(rts_badredirect, "\t{:bad-redirects/%hu} "
+	  "{N:/bad routing redirect%s}\n");
+	p(rts_dynamic, "\t{:dynamically-created/%hu} "
+	  "{N:/dynamically created route%s}\n");
+	p(rts_newgateway, "\t{:new-gateways/%hu} "
+	  "{N:/new gateway%s due to redirects}\n");
+	p(rts_unreach, "\t{:unreachable-destination/%hu} "
+	  "{N:/destination%s found unreachable}\n");
+	p(rts_wildcard, "\t{:wildcard-uses/%hu} "
+	  "{N:/use%s of a wildcard route}\n");
 #undef p
 
 	if (rttrash || sflag <= 1)
-		printf("\t%u route%s not in table but not freed\n",
-		    rttrash, plural(rttrash));
+		xo_emit("\t{:unused-but-not-freed/%u} "
+			"{N:/route%s not in table but not freed}\n",
+			rttrash, plural(rttrash));
 }
 
 char *
